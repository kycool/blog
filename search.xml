<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>资源加速系列之 Github</title>
    <url>/posts/19128/</url>
    <content><![CDATA[<h3 id="1-故事发生背景"><a href="#1-故事发生背景" class="headerlink" title="1 故事发生背景"></a>1 故事发生背景</h3><p>这段时间，github 的 clone 快搞死人了，速度慢的一逼，上网看了几种方法<span id="more"></span></p>
<ol>
<li>改 hosts （亲测差异不大）</li>
<li>先拉到 gitee，再从 gitee 克隆</li>
<li>走代理</li>
</ol>
<p>我使用了代理，第二种方法不适合我，为什么，一个是自己懒，另外一个就是安装某些软件，这些软件特么的自己写死了 clone 地址（一般都是不能改的），所以果断抛弃，直奔第三种方式</p>
<!--more-->

<h3 id="2-执行方法"><a href="#2-执行方法" class="headerlink" title="2 执行方法"></a>2 执行方法</h3><p><strong>走代理，你特么的需要个梯子呀</strong></p>
<p>我使用的是 ss 服务，看图说话</p>
<p><img src="/images/addGithubSpeed_ssproxy.png" alt="ssproxy.png"></p>
<p>很清晰，没毛病，然后进行下一步</p>
<p>不同的协议他的代理配置各不相同</p>
<ul>
<li><code>core.gitproxy</code>  用于  <code>git://</code>  协议</li>
<li><code>http.proxy</code>  用于  <code>http://</code>  协议</li>
<li><code>https.proxy</code>  用于  <code>https://</code>  协议</li>
</ul>
<p>全局设置 git 的配置</p>
<pre><code># 这里是针对 http 和 https 协议的
git config --global http.proxy &#39;socks5://127.0.0.1:1086&#39;
git config --global https.proxy &#39;socks5://127.0.0.1:1086&#39;

# 这里是针对 git 协议的
git config --global core.gitproxy &quot;git-proxy&quot;
git config --global socks.proxy &#39;socks5://127.0.0.1:1086&#39;
</code></pre>
<p>设置完后, 看下 git 的全局配置 <code>git config --global --list</code></p>
<pre><code class="python">user.name=xxxx
user.email=xxxxx@gmail.com
core.excludesfile=/Users/kycool/.gitignore_global
core.gitproxy=git-proxy
difftool.sourcetree.cmd=opendiff &quot;$LOCAL&quot; &quot;$REMOTE&quot;
difftool.sourcetree.path=
mergetool.sourcetree.cmd=/Applications/Sourcetree.app/Contents/Resources/opendiff-w.sh &quot;$LOCAL&quot; &quot;$REMOTE&quot; -ancestor &quot;$BASE&quot; -merge &quot;$MERGED&quot;
mergetool.sourcetree.trustexitcode=true
commit.template=/Users/kycool/.stCommitMsg
http.proxy=socks5://127.0.0.1:1086
https.proxy=socks5://127.0.0.1:1086
socks.proxy=socks5://127.0.0.1:1086
</code></pre>
<p>如果后面想删掉这些配置，则可以执行以下命令</p>
<pre><code class="python">git config --global --unset 键
</code></pre>
<p>添加 ssh 配置，在 <code>.ssh/config</code> 文件中添加</p>
<pre><code class="python">Host github.com
HostName github.com
User git
port 22
UseKeychain yes
IdentityFile /Users/kycool/.ssh/id_rsa
ProxyCommand nc -v -x 127.0.0.1:1086 %h %p
</code></pre>
<p>好了，到享受的时候了，我测试了 git 协议和 https 协议</p>
<h3 id="3-克隆测试"><a href="#3-克隆测试" class="headerlink" title="3 克隆测试"></a>3 克隆测试</h3><p><strong>git 协议</strong>: clone antd-pro</p>
<pre><code class="python">$ git clone git@github.com:ant-design/ant-design-pro.git
Cloning into &#39;ant-design-pro&#39;...
remote: Enumerating objects: 31, done.
remote: Counting objects: 100% (31/31), done.
remote: Compressing objects: 100% (29/29), done.
remote: Total 18085 (delta 9), reused 14 (delta 2), pack-reused 18054
Receiving objects: 100% (18085/18085), 6.02 MiB | 299.00 KiB/s, done.
Resolving deltas: 100% (12239/12239), done.
</code></pre>
<p>从来没有见过的速度，几乎是秒杀</p>
<p><strong>https 协议</strong>: hexo init mm</p>
<pre><code class="python">$ hexo init mm
INFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.git
Cloning into &#39;/Users/kycool/Documents/test/mm&#39;...
remote: Enumerating objects: 30, done.
remote: Counting objects: 100% (30/30), done.
remote: Compressing objects: 100% (24/24), done.
remote: Total 161 (delta 12), reused 12 (delta 4), pack-reused 131
Receiving objects: 100% (161/161), 31.79 KiB | 206.00 KiB/s, done.
Resolving deltas: 100% (74/74), done.
Submodule &#39;themes/landscape&#39; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#39;themes/landscape&#39;
Cloning into &#39;/Users/kycool/Documents/test/mm/themes/landscape&#39;...
remote: Enumerating objects: 9, done.
remote: Counting objects: 100% (9/9), done.
remote: Compressing objects: 100% (9/9), done.
remote: Total 1063 (delta 1), reused 1 (delta 0), pack-reused 1054
Receiving objects: 100% (1063/1063), 3.22 MiB | 217.00 KiB/s, done.
Resolving deltas: 100% (582/582), done.
Submodule path &#39;themes/landscape&#39;: checked out &#39;73a23c51f8487cfcd7c6deec96ccc7543960d350&#39;
INFO  Install dependencies
</code></pre>
<p>速度和上面一个几乎不相上下。</p>
<p>测试的速度是不断变化的，我观察有瞬间跑到 600 KiB&#x2F;s，我估摸着如果代理服务器的带宽牛逼的话，那速度想都不敢想。</p>
<h3 id="4-不足的地方"><a href="#4-不足的地方" class="headerlink" title="4 不足的地方"></a>4 不足的地方</h3><p>这里面的哪一种方法都是有些不足的，梯子偶尔也会抽风，因为是我买的别人家的服务，这种保障不能主观控制，抽风就回到解放前了。</p>
]]></content>
      <categories>
        <category>资源加速</category>
      </categories>
      <tags>
        <tag>加速</tag>
      </tags>
  </entry>
  <entry>
    <title>资源加速系列之 pip</title>
    <url>/posts/26327/</url>
    <content><![CDATA[<p>在 <code>python</code> 项目中，安装包时，都会从官方默认的源：<span id="more"></span></p>
<pre><code>https://pypi.org/simple
</code></pre>
<p>中下载，速度较慢，原因不多说了，针对这个情况，国内有些公司和机构做了镜像站，以便国内的用户提高下载速度。</p>
<!--more-->

<h3 id="1-国内的镜像源列表"><a href="#1-国内的镜像源列表" class="headerlink" title="1 国内的镜像源列表"></a>1 国内的镜像源列表</h3><p>列举几个常用的，少用的就不列了</p>
<ul>
<li><a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a> 阿里云</li>
<li><a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a> 清华大学</li>
<li><a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a> 豆瓣</li>
<li><a href="https://mirrors.ustc.edu.cn/pypi/web/simple/">https://mirrors.ustc.edu.cn/pypi/web/simple/</a> 中国科学技术大学</li>
</ul>
<p>上面的源站都测试过，对我来说，首选阿里云，因为确实快</p>
<h3 id="2-临时指定镜像源"><a href="#2-临时指定镜像源" class="headerlink" title="2 临时指定镜像源"></a>2 临时指定镜像源</h3><pre><code>pip install -i 镜像源地址 包名称
</code></pre>
<p>例如安装 <code>django</code>，选用阿里云镜像源，则</p>
<pre><code>pip install -i https://mirrors.aliyun.com/pypi/simple/ django
</code></pre>
<h3 id="3-全局设置镜像源"><a href="#3-全局设置镜像源" class="headerlink" title="3 全局设置镜像源"></a>3 全局设置镜像源</h3><p>我个人使用的是 mac，步骤：</p>
<p>1 在用户主目录下 <code>~/.config</code> 中新建 <code>pip</code> 文件夹（也可以直接在用户主目录下建立 <code>.pip</code> 文件夹)</p>
<p>2 在上一步新建的文件中新建 <code>pip.conf</code></p>
<p>3 在 <code>pip.conf</code> 文件中添加以下配置</p>
<pre><code class="python">[global]
timeout = 60
index-url = https://mirrors.aliyun.com/pypi/simple

[install]
trusted-host=mirrors.aliyun.com
</code></pre>
<p>可以阅览官方文档：<a href="https://pip.pypa.io/en/stable/user_guide/#config-file">https://pip.pypa.io/en/stable/user_guide/#config-file</a></p>
<pre><code>You can set a custom path location for this config
file using the environment variable PIP_CONFIG_FILE.
</code></pre>
<p>用户可以自定义配置文件路径，配置好环境变量 <code>PIP_CONFIG_FILE</code> 即可。</p>
<p>后续再安装 <code>python</code> 包都会使用设置好的源，节省时间。</p>
]]></content>
      <categories>
        <category>资源加速</category>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>加速</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>简单备份文件并发送到指定邮箱</title>
    <url>/posts/13676/</url>
    <content><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><p>一哥们发了个诉求，总觉得自己的服务器不安全，想搞个定时备份文件并发送到自己的邮箱</p>
<span id="more"></span>

<h3 id="2-实现代码如下"><a href="#2-实现代码如下" class="headerlink" title="2 实现代码如下"></a>2 实现代码如下</h3><pre><code class="python"># -*- coding: utf-8 -*-

from __future__ import absolute_import, unicode_literals

import os
import datetime
import logging
import logging.config

from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header
from email.mime.application import MIMEApplication
import smtplib

name = datetime.datetime.now().strftime(&quot;%Y%m%d%H%M%S&quot;)
base_path = &#39;/root/xxxx/temp&#39;
zip_path = &#39;/root/xxxx/backup/&#123;&#125;.tar.bz2&#39;.format(name)


def set_logging():
    &quot;&quot;&quot;&quot;&quot;&quot;

    log_dir, log_file = &#39;/root/xxxx/logs&#39;, &#39;/root/xxxx/logs/backup.log&#39;

    if not os.path.exists(log_dir):
        os.mkdir(log_dir)

    if not os.path.exists(log_file):
        open(log_file, &#39;w&#39;)

    DEFAULT_LOGGING = &#123;
        &#39;version&#39;: 1,
        &#39;disable_existing_loggers&#39;: False,
        &#39;formatters&#39;: &#123;
            &#39;formatone&#39;: &#123;
                &#39;format&#39;: &#39;[%(asctime)s] %(levelname)s : %(message)s&#39;,
            &#125;
        &#125;,
        &#39;handlers&#39;: &#123;
            &#39;file&#39;: &#123;
                &#39;level&#39;: &#39;DEBUG&#39;,
                &#39;filename&#39;: &#39;/root/xxxx/logs/backup.log&#39;,
                &#39;formatter&#39;: &#39;formatone&#39;,
                &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;,
                &#39;maxBytes&#39;: 100 * 1024 * 1024,
                &#39;backupCount&#39;: 10,
            &#125;,
        &#125;,
        &#39;loggers&#39;: &#123;
            &#39;backup&#39;: &#123;
                &#39;handlers&#39;: [&#39;file&#39;],
                &#39;level&#39;: &#39;INFO&#39;,
            &#125;,
        &#125;
    &#125;

    logging.config.dictConfig(DEFAULT_LOGGING)


def zip_files():
    &quot;&quot;&quot;zip files&quot;&quot;&quot;
    os.system(&#39;tar -cjf &#123;&#125; -C &#123;&#125; data&#39;.format(zip_path, base_path))


def sendmail():
    &quot;&quot;&quot;send mail&quot;&quot;&quot;
    set_logging()
    zip_files()

    logger = logging.getLogger(&#39;backup&#39;)

    mail_from, password = &#39;xxxxxxx@aliyun.com&#39;, &#39;xxxxxxx&#39;
    mail_to = &#39;xxxxx@qq.com&#39;
    smtp_server = &#39;smtp.aliyun.com&#39;

    msgRoot = MIMEMultipart(&#39;related&#39;)
    msgRoot[&#39;Subject&#39;] = &#39;send backup files &#123;&#125;&#39;.format(name)
    msgRoot[&#39;From&#39;] = &#39;&#123;&#125;&lt;&#123;&#125;&gt;&#39;.format(Header(&#39;backup&#39;, &#39;utf-8&#39;), mail_from)
    msgRoot[&#39;To&#39;] = mail_to

    msgText = MIMEText(&#39;backup files&#39;, &#39;plain&#39;, &#39;utf-8&#39;)
    msgRoot.attach(msgText)

    zip_con = MIMEApplication(open(zip_path,&#39;rb&#39;).read())
    zip_con.add_header(&#39;Content-Disposition&#39;, &#39;attachment&#39;,
                       filename=&#39;&#123;&#125;.tar.bz2&#39;.format(name))
    msgRoot.attach(zip_con)

    try:
        server = smtplib.SMTP_SSL(smtp_server)
        server.login(mail_from, password)
        server.sendmail(mail_from, mail_to, msgRoot.as_string())
        server.quit()
        logger.info(&#39;send &#123;&#125; backup files success&#39;.format(name))
    except Exception, e:
        logger.error(&#39;send &#123;&#125; failed &#123;&#125;&#39;.format(name, e))
        sendmail()


if __name__ == &#39;__main__&#39;:
    sendmail()
</code></pre>
<h3 id="3-简单说明"><a href="#3-简单说明" class="headerlink" title="3 简单说明"></a>3 简单说明</h3><h4 id="3-1-打包文件"><a href="#3-1-打包文件" class="headerlink" title="3.1 打包文件"></a>3.1 打包文件</h4><p>这个实现比较初级，直接用 <code>shell</code> 命令进行打包</p>
<pre><code class="python">def zip_files():
    &quot;&quot;&quot;zip files&quot;&quot;&quot;
    os.system(&#39;tar -cjf &#123;&#125; -C &#123;&#125; data&#39;.format(zip_path, base_path))
</code></pre>
<h4 id="3-2-发送邮件"><a href="#3-2-发送邮件" class="headerlink" title="3.2 发送邮件"></a>3.2 发送邮件</h4><p>这个就不说了，现成的模块直接拿来用</p>
<h4 id="3-3-日志记录"><a href="#3-3-日志记录" class="headerlink" title="3.3 日志记录"></a>3.3 日志记录</h4><p>加上日志，可以很清楚的让我知道发送情况如下，示例如下：</p>
<pre><code class="javascript">[2017-04-14 00:00:03,251] INFO : send 20170414000001 backup files success
[2017-04-14 03:00:02,620] INFO : send 20170414030001 backup files success
[2017-04-14 06:00:02,406] INFO : send 20170414060001 backup files success
[2017-04-14 09:00:02,349] INFO : send 20170414090001 backup files success
[2017-04-14 12:00:02,299] INFO : send 20170414120001 backup files success
[2017-04-14 15:01:04,696] ERROR : send 20170414150001 failed [Errno 110] Connection timed out
[2017-04-14 15:01:05,401] INFO : send 20170414150001 backup files success
</code></pre>
<h4 id="3-4-定时处理"><a href="#3-4-定时处理" class="headerlink" title="3.4 定时处理"></a>3.4 定时处理</h4><p>定时这个处理，直接使用 <code>crontab</code> 命令，创建个 <code>backup_cron</code> 文件，写入</p>
<pre><code class="shell">0 */3 * * *  python /root/xxxxx/backup.py
</code></pre>
<h3 id="4-简单小结"><a href="#4-简单小结" class="headerlink" title="4 简单小结"></a>4 简单小结</h3><p>业务比较简单，实现也比较简单，没啥可说的</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>资源加速系列之 pyenv</title>
    <url>/posts/22631/</url>
    <content><![CDATA[<p>对于 <code>python</code> 相关的业务，我都是使用 <code>pyenv</code>，来管理我本地的 <code>python</code> 版本，由于不同项目的需要，有些项目使用的 <code>python</code> 版本都是不一致，所以本地安装了不同的版本。<span id="more"></span></p>
<h3 id="1-加速"><a href="#1-加速" class="headerlink" title="1 加速"></a>1 加速</h3><p>刚开始装 <code>python</code>，都是执行 <code>pyenv install 版本号</code> 进行安装，但是发现速度，在国内，你懂得，太慢，所以就去找镜像，我使用了淘宝的镜像，地址如下</p>
<pre><code>https://npm.taobao.org/mirrors/python/
</code></pre>
<p>其实加速就是从镜像地址把指定版本的 <code>python</code> 压缩包下载到 <code>~/.pyenv/cache</code> 下面，然后执行 <code>pyenv install 对应的版本号</code> 即可。</p>
<p>例如安装 3.6.7 版本，命令行如下</p>
<pre><code>v=3.6.7;wget https://npm.taobao.org/mirrors/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v
</code></pre>
<h3 id="2-做成可执行文件"><a href="#2-做成可执行文件" class="headerlink" title="2 做成可执行文件"></a>2 做成可执行文件</h3><p>我个人是有懒癌的，如果每次安装其他版本，都要这么执行，输入一长串，受不鸟，那就封装成 <code>shell</code> 脚本，脚本如下：</p>
<pre><code class="bash">#!/bin/bash

function pyenvInstallPython()
&#123;
    echo $1
    v=$1
    wget https://npm.taobao.org/mirrors/python/$v/Python-$v.tar.xz -P ~/.pyenv/cache/;pyenv install $v
&#125;

pyenvInstallPython $*
</code></pre>
<p>然后把这个脚本写到可执行文件（我起的名字叫做 <code>pyversion</code>)中，然后把可执行文件移动到可执行目录中（即能在 <code>$PATH</code> 指定的路径中找到这个文件），我个人的做法，在我的用户目录建立了一个 <code>bin</code> 目录（加入到 <code>$PATH</code> 中去），然后把 <code>pyversion</code> 这个可执行文件移动到 <code>~/bin</code> 中去。</p>
<p>好了，可以了，后面想安装对应的版本，直接在终端中执行</p>
<pre><code>pyversion 版本号
</code></pre>
<h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3 测试"></a>3 测试</h3><p>例如我要装 3.6.7 版本，在终端执行 <code>pyversion 3.6.7</code>，执行结果：</p>
<pre><code class="shell">3.6.7
--2016-10-22 01:16:10--  https://npm.taobao.org/mirrors/python/3.6.7/Python-3.6.7.tar.xz
正在解析主机 npm.taobao.org (npm.taobao.org)... 114.55.80.225
正在连接 npm.taobao.org (npm.taobao.org)|114.55.80.225|:443... 已连接。
已发出 HTTP 请求，正在等待回应... 302 Found
位置：https://cdn.npm.taobao.org/dist/python/3.6.7/Python-3.6.7.tar.xz [跟随至新的 URL]
--2016-10-22 01:16:10--  https://cdn.npm.taobao.org/dist/python/3.6.7/Python-3.6.7.tar.xz
正在解析主机 cdn.npm.taobao.org (cdn.npm.taobao.org)... 119.147.111.226, 119.147.111.229, 113.105.168.156, ...
正在连接 cdn.npm.taobao.org (cdn.npm.taobao.org)|119.147.111.226|:443... 已连接。
已发出 HTTP 请求，正在等待回应... 200 OK
长度：17178476 (16M) [application/x-xz]
正在保存至: “/Users/kycool/.pyenv/cache/Python-3.6.7.tar.xz”

Python-3.6.7.tar.xz              100%[========================================================&gt;]  16.38M  8.36MB/s  用时 2.0s

2016-10-22 01:16:12 (8.36 MB/s) - 已保存 “/Users/kycool/.pyenv/cache/Python-3.6.7.tar.xz” [17178476/17178476])

python-build: use openssl@1.1 from homebrew
python-build: use readline from homebrew
Installing Python-3.6.7...
python-build: use readline from homebrew
python-build: use zlib from xcode sdk
Installed Python-3.6.7 to /Users/kycool/.pyenv/versions/3.6.7
</code></pre>
<p>速度果然是杠杠的，再输入 <code>pyenv versions</code> 看下</p>
<pre><code>$ pyenv versions
* system (set by /Users/kycool/.pyenv/version)
  3.6.0
  3.6.7
</code></pre>
<p>可以，后续就可以这样玩了，省时省力。</p>
]]></content>
      <categories>
        <category>资源加速</category>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>加速</tag>
        <tag>镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian | Media change please insert the disc labeled</title>
    <url>/posts/20380/</url>
    <content><![CDATA[<p>使用 <code>apt install xxx</code> 时，出现下面的报错</p>
<span id="more"></span>

<pre><code class="shell">Media change: please insert the disc labeled

media change: please insert the disc labeled
Debian 10.9.3 - Release amd64 (20210327.10) in the drive /media/cdrom/ and press enter
</code></pre>
<p>查看下 <code>/etc/apt/sources.list</code></p>
<pre><code class="python"># deb cdrom:[Debian GNU/Linux 10.9.0 _Buster_ - Official amd64 DVD Binary-1 20210327-10:39]/ buster contrib main

deb cdrom:[Debian GNU/Linux 10.9.0 _Buster_ - Official amd64 DVD Binary-1 20210327-10:39]/ buster contrib main

deb http://security.debian.org/debian-security buster/updates main contrib
deb-src http://security.debian.org/debian-security buster/updates main contrib

# buster-updates, previously known as &#39;volatile&#39;
# A network mirror was not selected during install.  The following entries
# are provided as examples, but you should amend them as appropriate
# for your mirror of choice.
#
# deb http://deb.debian.org/debian/ buster-updates main contrib
# deb-src http://deb.debian.org/debian/ buster-updates main contrib
</code></pre>
<p>果断把包含 <code>deb cdrom</code> 这行给注释掉，然后又重新把 <code>apt</code> 源设置成清华源，修改后的文件</p>
<pre><code class="python">
# deb cdrom:[Debian GNU/Linux 10.9.0 _Buster_ - Official amd64 DVD Binary-1 20210327-10:39]/ buster contrib main

# deb cdrom:[Debian GNU/Linux 10.9.0 _Buster_ - Official amd64 DVD Binary-1 20210327-10:39]/ buster contrib main

# deb https://security.debian.org/debian-security buster/updates main contrib
# deb-src http://security.debian.org/debian-security buster/updates main contrib

# buster-updates, previously known as &#39;volatile&#39;
# A network mirror was not selected during install.  The following entries
# are provided as examples, but you should amend them as appropriate
# for your mirror of choice.
#
# deb http://deb.debian.org/debian/ buster-updates main contrib
# deb-src http://deb.debian.org/debian/ buster-updates main contrib

# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free
deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free
deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free
deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free
deb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free
deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free
</code></pre>
<p>然后执行 <code>apt update</code>，最后重新安装软件成功。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title>Antd：Form 的 InitialValues 重置</title>
    <url>/posts/59046/</url>
    <content><![CDATA[<p>描述：编辑页面中 <code>Form</code> 的 <code>InitialValues</code> 的重置</p>
<span id="more"></span>

<h3 id="1-场景描述"><a href="#1-场景描述" class="headerlink" title="1 场景描述"></a>1 场景描述</h3><p>管理后台的通用场景，列表页面，然后点击新建或者更新，这里说的是更新的场景，异步请求，重新渲染表单。</p>
<p>管理后台使用 <code>antd-pro</code> 搭建，<code>antd</code> 使用了 <code>4.x</code> 版本，注意这个版本对 <code>Form</code> 做了些调整。</p>
<p>点击更新进入表单页面，我设置了 <code>state</code> 的初始值</p>
<pre><code>  state = &#123;
    initialValues: &#123;&#125;,
  &#125;;
</code></pre>
<p>然后异步请求，请求到结果后，需要重置 <code>initialValues</code>，但是根据 <code>antd</code> 的文档</p>
<pre><code>initialValue 表单默认值，只有初始化以及重置时生效
</code></pre>
<p>所以异步请求后如果重新 <code>setState(&#123; initialValues &#125;)</code>，这样是无效的，你会看到对应的表单中没有数据，都是空的。只能重置，这种问题怎么解决掉</p>
<h3 id="2-重置-initialValues"><a href="#2-重置-initialValues" class="headerlink" title="2 重置 initialValues"></a>2 重置 initialValues</h3><p><strong>2.1 如果是函数式组件，官方推荐使用 <code>Form.useForm</code> 创建表单数据域进行控制</strong></p>
<p>使用用法如下：</p>
<pre><code class="javascript">const [form] = Form.useForm();

// 在异步请求中重置表单初始值
asyncRequest().then((initialValues) =&gt; form.setFieldsValue(&#123; initialValues &#125;));
</code></pre>
<p><strong>2.2 如果是在 class component 下，你也可以通过 ref 获取数据域</strong></p>
<pre><code class="javascript">class Demo extends React.Component &#123;
  formRef = React.createRef();

  UNSAFE_componentWillMount = () =&gt; &#123;
    // 在异步请求中重置表单初始值
    asyncRequest().then((initialValues) =&gt; &#123;
      this.formRef.current.setFieldsValue(&#123; initialValues &#125;);
    &#125;);
  &#125;;
&#125;
</code></pre>
<p>对于 <code>UNSAFE_componentWillMount</code> 声明周期函数，有些声明周期函数在未来版本中会被移除或者重命名，这个可以浏览 <a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html">https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html</a></p>
<h3 id="3-完整的参考示例"><a href="#3-完整的参考示例" class="headerlink" title="3 完整的参考示例"></a>3 完整的参考示例</h3><p>这里我使用了类组件</p>
<pre><code class="javascript">import React from &quot;react&quot;;
import &#123; Form, Input, Button &#125; from &quot;antd&quot;;
import FairyUploader from &quot;@/fairy/components/Uploader&quot;;
import FairyRichTextEditor from &quot;@/fairy/components/RichTextEditor&quot;;
import store from &quot;@/utils/store&quot;;

export default class CreateUpdateForm extends React.Component &#123;
  state = &#123;
    create: true,
    initialValues: &#123;&#125;,
  &#125;;

  formRef = React.createRef();

  async UNSAFE_componentWillMount() &#123;
    const &#123; id &#125; = this.props.match.params;

    // 获取数据详情
    if (id) &#123;
      this.setState(&#123; create: false &#125;);
      store
        .dispatch(&#123;
          type: &quot;product/retrieve&quot;,
          payload: &#123; id &#125;,
        &#125;)
        .then((initialValues) =&gt; &#123;
          this.formRef.current.setFieldsValue(initialValues);
        &#125;);
    &#125;
  &#125;

  onFinish = (values) =&gt; &#123;
    console.log(&quot;Success:&quot;, values);
  &#125;;

  onFinishFailed = (errorInfo) =&gt; &#123;
    console.log(&quot;Failed:&quot;, errorInfo);
  &#125;;

  render() &#123;
    const &#123; initialValues, create &#125; = this.state;
    const formProps = &#123;
      name: &quot;basic&quot;,
      onFinish: this.onFinish,
      onFinishFailed: this.onFinishFailed,
      initialValues,
      ref: this.formRef,
    &#125;;

    return (
      &lt;Form &#123;...formProps&#125;&gt;
        &lt;Form.Item
          label=&quot;姓名&quot;
          name=&quot;name&quot;
          rules=&#123;[&#123; required: true, message: &quot;请填写姓名&quot; &#125;]&#125;
        &gt;
          &lt;Input /&gt;
        &lt;/Form.Item&gt;

        &lt;Form.Item
          label=&quot;职业&quot;
          name=&quot;position&quot;
          rules=&#123;[&#123; required: true, message: &quot;请输入职业&quot; &#125;]&#125;
        &gt;
          &lt;Input /&gt;
        &lt;/Form.Item&gt;

        &lt;Form.Item
          label=&quot;头像&quot;
          name=&quot;avatar&quot;
          rules=&#123;[&#123; required: true, message: &quot;请上传头像&quot; &#125;]&#125;
        &gt;
          &lt;FairyUploader /&gt;
        &lt;/Form.Item&gt;

        &lt;Form.Item
          label=&quot;描述&quot;
          name=&quot;description&quot;
          rules=&#123;[&#123; required: true, message: &quot;请输入描述&quot; &#125;]&#125;
        &gt;
          &lt;FairyRichTextEditor /&gt;
        &lt;/Form.Item&gt;

        &lt;Form.Item&gt;
          &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt;
            &#123;create ? &quot;保存&quot; : &quot;更新&quot;&#125;
          &lt;/Button&gt;
        &lt;/Form.Item&gt;
      &lt;/Form&gt;
    );
  &#125;
&#125;
</code></pre>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h3><ul>
<li><code>antd</code> 对于各种使用场景还是给出了详细的说明和例子参考的，这个很赞。</li>
<li>使用 <code>React</code> 的各种警告，这个需要认真根据官方的引导进行调整。</li>
<li>根据上面的参考示例可以想到对于这种通用的更新创建表单，完全可以使用通用的 <code>HOC</code>，根据不同的配置渲染出不同的页面，这样一个高阶组件可以解决掉通用的创建更新表单。同样，对于列表页面也是如此，其实说白了，管理后台可以根据配置生成出来。对于一些需要自定义的业务，可以让高阶组件支持继承和钩子的重置来解决，如果实在解决不了的业务，可以单独写页面也是可以的。对于这个，我会专门写一篇文章来陈述下。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>redux</tag>
        <tag>Antd</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 虚拟字段</title>
    <url>/posts/37001/</url>
    <content><![CDATA[<p>这次写写 Django 模型中的虚拟字段。这个虚拟字段很有意思，在某些场景下，反查可以让业务代码看起来很清晰，大部分时候都是结合 <code>prefetch_related</code> 和 <code>select_related</code> 来使用。<span id="more"></span></p>
<h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h3><pre><code class="python">class Category(models.Model):
    user = models.ForeignKey(
        to=settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name=&#39;category_user&#39;,
        null=True,
        default=None,
    )

class Article(models.Model):
    user = models.OneToOneField(to=settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    category = models.ManyToManyField(Category)

class Book(models.Model):
    article = models.OneToOneField(
        Article, on_delete=models.CASCADE, related_name=&#39;books&#39;
    )

class Tag(models.Model):
    article = models.ForeignKey(Article, on_delete=models.CASCADE)
    users = models.ManyToManyField(User, related_name=&#39;tag_users&#39;)
</code></pre>
<p>这里写了分类模型和文章模型，里面包含了基本的三种关系：</p>
<ul>
<li>OneToOneField</li>
<li>ForeignKey</li>
<li>ManyToManyField</li>
</ul>
<h3 id="2-模型中的虚拟字段"><a href="#2-模型中的虚拟字段" class="headerlink" title="2 模型中的虚拟字段"></a>2 模型中的虚拟字段</h3><p>虚拟字段一般存在于父模型中。对于上述三种关系，虚拟字段的名称都会受是否指定 <code>related_name</code> 的影响。</p>
<p><strong>规则 1：</strong></p>
<blockquote>
<p>如果引用模型指定了 related_name，那么父模型（被引用模型）存在指定的 related_name 名称的字段</p>
</blockquote>
<p><strong>规则 2：</strong></p>
<blockquote>
<p>如果没有指定 related_name，那么父模型（被引用模型）存在子模型小写名称的字段</p>
</blockquote>
<h4 id="2-1-OneToOneField-关系下的验证"><a href="#2-1-OneToOneField-关系下的验证" class="headerlink" title="2.1 OneToOneField 关系下的验证"></a>2.1 OneToOneField 关系下的验证</h4><h5 id="2-1-1-指定了-related-name"><a href="#2-1-1-指定了-related-name" class="headerlink" title="2.1.1 指定了 related_name"></a>2.1.1 指定了 related_name</h5><pre><code class="python">In [5]: Article._meta.get_field(&#39;books&#39;)
Out[5]: &lt;OneToOneRel: mallshop.book&gt;

In [7]: Article._meta.get_field(&#39;books&#39;).concrete
Out[7]: False
</code></pre>
<p><code>Book</code> 模型引用了 <code>Article</code> 模型，同时指定了 <code>related_name</code>, 这时 <code>Article</code> 模型存在 <code>books</code> 的虚拟字段</p>
<h5 id="2-1-2-没有指定-related-name"><a href="#2-1-2-没有指定-related-name" class="headerlink" title="2.1.2 没有指定 related_name"></a>2.1.2 没有指定 related_name</h5><pre><code class="python">In [8]: User._meta.get_field(&#39;article&#39;)
Out[8]: &lt;OneToOneRel: mallshop.article&gt;

In [9]: User._meta.get_field(&#39;article&#39;).concrete
Out[9]: False
</code></pre>
<p><code>Article</code> 模型引用了 <code>User</code> 模型，没有指定 <code>related_name</code>，这时 <code>User</code> 模型存在 <code>artilce</code> 虚拟字段</p>
<h4 id="2-2-ForeignKey-关系下的验证"><a href="#2-2-ForeignKey-关系下的验证" class="headerlink" title="2.2 ForeignKey 关系下的验证"></a>2.2 ForeignKey 关系下的验证</h4><h5 id="2-2-1-指定了-related-name"><a href="#2-2-1-指定了-related-name" class="headerlink" title="2.2.1 指定了 related_name"></a>2.2.1 指定了 related_name</h5><pre><code class="python">In [10]: User._meta.get_field(&#39;category_user&#39;)
Out[10]: &lt;ManyToOneRel: mallshop.category&gt;

In [11]: User._meta.get_field(&#39;category_user&#39;).concrete
Out[11]: False
</code></pre>
<p><code>Category</code> 模型引用了 <code>User</code> 模型，同时指定了 <code>related_name</code>, 这时 <code>User</code> 模型存在 <code>category_user</code> 的虚拟字段</p>
<h5 id="2-2-2-没有指定-related-name"><a href="#2-2-2-没有指定-related-name" class="headerlink" title="2.2.2 没有指定 related_name"></a>2.2.2 没有指定 related_name</h5><pre><code class="python">In [12]: Article._meta.get_field(&#39;tag&#39;)
Out[12]: &lt;ManyToOneRel: mallshop.tag&gt;

In [13]: Article._meta.get_field(&#39;tag&#39;).concrete
Out[13]: False
</code></pre>
<p><code>Tag</code> 模型引用了 <code>Article 模型</code>，没有指定 <code>related_name</code>，这时 <code>Article</code> 模型存在 <code>tag</code> 虚拟字段</p>
<h4 id="2-3-ManyToManyField-关系下的验证"><a href="#2-3-ManyToManyField-关系下的验证" class="headerlink" title="2.3 ManyToManyField 关系下的验证"></a>2.3 ManyToManyField 关系下的验证</h4><h5 id="2-3-1-指定了-related-name"><a href="#2-3-1-指定了-related-name" class="headerlink" title="2.3.1 指定了 related_name"></a>2.3.1 指定了 related_name</h5><pre><code class="python">In [1]: User._meta.get_field(&#39;tag_users&#39;)
Out[1]: &lt;ManyToManyRel: mallshop.tag&gt;

In [2]: User._meta.get_field(&#39;tag_users&#39;).concrete
Out[2]: False
</code></pre>
<p><code>Tag</code> 模型引用了 <code>User</code> 模型，同时指定了 <code>related_name</code> 为 <code>tag_users</code>, 这时 <code>User</code> 模型存在 <code>tag_users</code> 的虚拟字段</p>
<h5 id="2-3-2-没有指定-related-name"><a href="#2-3-2-没有指定-related-name" class="headerlink" title="2.3.2 没有指定 related_name"></a>2.3.2 没有指定 related_name</h5><pre><code class="python">In [15]: Category._meta.get_field(&#39;article&#39;)
Out[15]: &lt;ManyToManyRel: mallshop.article&gt;

In [16]: Category._meta.get_field(&#39;article&#39;).concrete
Out[16]: False
</code></pre>
<p><code>Article</code> 模型引用了 <code>Category</code> 模型，没有指定 <code>related_name</code>，这时 <code>Category</code> 模型存在 <code>article</code> 虚拟字段</p>
<h3 id="3-模型实例访问虚拟字段"><a href="#3-模型实例访问虚拟字段" class="headerlink" title="3 模型实例访问虚拟字段"></a>3 模型实例访问虚拟字段</h3><p>如果在模型实例，访问虚拟字段时，这里需要注意以下规则：</p>
<p><strong>规则 1：</strong></p>
<blockquote>
<p>如果是 OneToOneField 关系，访问模型实例的虚拟字段属性时，这时返回的是子模型的实例</p>
</blockquote>
<pre><code class="python">In [3]: user = User.objects.first()

In [4]: user.article
Out[4]: &lt;Article: Article object (1)&gt;

In [5]: user.article.books
Out[5]: &lt;Book: Book object (1)&gt;
</code></pre>
<p><strong>规则 2：</strong></p>
<blockquote>
<p>如果是非 OneToOneField 关系，同时指定了 related_name，访问模型实例的虚拟字段属性时，这时返回的是 RelatedManager 实例</p>
</blockquote>
<pre><code class="python">In [9]: user.category_user
Out[9]: &lt;django.db.models.fields.related_descriptors.create_reverse_many_to_one_manager.&lt;locals&gt;.RelatedManager at 0x107c10610&gt;
</code></pre>
<p><strong>规则 3：</strong></p>
<blockquote>
<p>如果是非 OneToOneField 关系，同时没有指定 related_name，访问模型实例的虚拟字段属性时，这个时候会抛出异常，如果想得到一个 RelatedManager 实例，则需要在虚拟字段后加上 _set 后，在进行访问</p>
</blockquote>
<pre><code class="python">In [6]: article = Article.objects.first()

In [7]: article.tag
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-7-ad987724bf64&gt; in &lt;module&gt;
----&gt; 1 article.tag

AttributeError: &#39;Article&#39; object has no attribute &#39;tag&#39;

In [8]: article.tag_set
Out[8]: &lt;django.db.models.fields.related_descriptors.create_reverse_many_to_one_manager.&lt;locals&gt;.RelatedManager at 0x108053220&gt;
</code></pre>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h3><p>虚拟字段，注意在模型和模型实例下的使用方式。</p>
<p>话说虚拟字段有啥用，可以反查，在我使用的场景中，最大的好处是可以基于 <code>DRF</code> 动态构建序列化类，例如想得到一篇文章，这个文章还要包含些作者信息，前端可以这样传</p>
<pre><code class="json">&#123;
  &quot;display_fields&quot;: [
    &quot;id&quot;,
    &quot;name&quot;,
    &#123; &quot;user&quot;: [&quot;username&quot;, &quot;id&quot;] &#125;,
    &#123; &quot;tag&quot;: [&quot;id&quot;, &quot;name&quot;] &#125;
  ]
&#125;
</code></pre>
<p>返回的结果</p>
<pre><code class="json">&#123;
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;ceshi1&quot;,
  &quot;user&quot;: &#123;
    &quot;username&quot;: &quot;吴小楠&quot;,
    &quot;id&quot;: 2
  &#125;,
  &quot;tag&quot;: [
    &#123;
      &quot;id&quot;: 3,
      &quot;name&quot;: &quot;tag1&quot;
    &#125;
  ]
&#125;
</code></pre>
<p>后端可以根据前端传递的获取字段列表进行校验，验证通过后根据获取的字段动态的生成对应的序列化类，嵌套的序列化类也只包含指定的字段，这样在服务端可以提升些接口性能。返回给前端，这个我是参考了 <code>graphql</code> 的模式，前端需要返回什么，就指定什么。</p>
<p>如果使用 Django，虚拟字段的使用时避免不了的，深度挖掘虚拟字段的使用，会跟业务带来很大的便利性。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | Mysql 返回不合法的日期时间对象</title>
    <url>/posts/26483/</url>
    <content><![CDATA[<h3 id="1-错误描述"><a href="#1-错误描述" class="headerlink" title="1 错误描述"></a>1 错误描述</h3><p>在查询数据集中的日期时间对象时</p>
<pre><code class="python">In [38]: Device.objects.datetimes(&#39;latest_alarm_time&#39;, &#39;month&#39;)

Out[38]: SELECT DISTINCT
CAST(DATE_FORMAT(CONVERT_TZ(`device_device`.`latest_alarm_time`, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;), &#39;%Y-%m-01 00:00:00&#39;) AS DATETIME) AS `datetimefield` FROM `device_device` WHERE `device_device`.`latest_alarm_time` IS NOT NULL ORDER BY `datetimefield` ASC LIMIT 21
</code></pre>
<p>然后报错</p>
<pre><code class="python">ValueError: Database returned an invalid datetime value. Are time zone definitions for your database installed?
</code></pre>
<h3 id="2-解决问题"><a href="#2-解决问题" class="headerlink" title="2 解决问题"></a>2 解决问题</h3><p>实际情况，数据库中是有数据，目测月份提取失败；到 mysql 执行了下</p>
<pre><code class="python">mysql root@localhost:py365&gt; select convert_tz(&#39;2018-05-10 12:30:00&#39;, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;);
+-------------------------------------------------------------+
| convert_tz(&#39;2018-05-10 12:30:00&#39;, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;)   |
|-------------------------------------------------------------|
| NULL                                                        |
+-------------------------------------------------------------+
</code></pre>
<p>果然，结果返回令人诧异的 <code>NULL</code></p>
<p>看了下 Django orm 的 datetimes 官方文档</p>
<pre><code class="python">Note
This function performs time zone conversions directly in the database. As a consequence, your database must be able to interpret the value of tzinfo.tzname(None). This translates into the following requirements:

SQLite: no requirements. Conversions are performed in Python with pytz (installed when you install Django).
PostgreSQL: no requirements (see Time Zones).
Oracle: no requirements (see Choosing a Time Zone File).
MySQL: load the time zone tables with mysql_tzinfo_to_sql.
</code></pre>
<p>即 mysql 需要使用 mysql_tzinfo_to_sql 载入时区表，接着跳到 <a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-tzinfo-to-sql.html">https://dev.mysql.com/doc/refman/8.0/en/mysql-tzinfo-to-sql.html</a></p>
<p>按照 mysql 官方的文档</p>
<p><code>For the first invocation syntax, pass the zoneinfo directory path name to mysql_tzinfo_to_sql and send the output into the mysql program. For example:</code></p>
<p>我需要按照以下命令执行</p>
<blockquote>
<p>mysql_tzinfo_to_sql &#x2F;usr&#x2F;share&#x2F;zoneinfo | mysql -u root mysql</p>
</blockquote>
<p>然后再次执行上面执行过的转换语句</p>
<pre><code class="python">mysql root@localhost:py365&gt; select convert_tz(&#39;2018-05-10 12:30:00&#39;, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;);
+-------------------------------------------------------------+
| convert_tz(&#39;2018-05-10 12:30:00&#39;, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;)   |
|-------------------------------------------------------------|
| 2018-05-10 20:30:00                                         |
+-------------------------------------------------------------+
</code></pre>
<p>yes，返回了正确的结果；</p>
<p>在 shell 中 执行数据库查询语句</p>
<pre><code class="python">In [45]: Device.objects.datetimes(&#39;latest_alarm_time&#39;, &#39;month&#39;)
Out[45]: SELECT DISTINCT CAST(DATE_FORMAT(CONVERT_TZ(`device_device`.`latest_alarm_time`, &#39;UTC&#39;, &#39;Asia/Shanghai&#39;), &#39;%Y-%m-01 00:00:00&#39;) AS DATETIME) AS `datetimefield` FROM `device_device` WHERE `device_device`.`latest_alarm_time` IS NOT NULL ORDER BY `datetimefield` ASC LIMIT 21


Execution time: 0.000591s [Database: default]

&lt;QuerySet [datetime.datetime(2018, 5, 1, 0, 0, tzinfo=&lt;DstTzInfo &#39;Asia/Shanghai&#39; CST+8:00:00 STD&gt;)]&gt;
</code></pre>
<p>正常，so 问题解决，看来还得认真看文档呀</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>DRF：书写接口的通用流程</title>
    <url>/posts/11214/</url>
    <content><![CDATA[<p>描述：书写接口的基本流程</p>
<span id="more"></span>

<p>在使用 <code>django-restful-framework</code> 写后台接口的业务中，在下通用的做法；</p>
<blockquote>
<p>前端数据数据—-&gt;检测(包含限流，认证，权限验证，数据检测)—-&gt;持久化</p>
</blockquote>
<p>其中对于限流和权限验证，都可以自定义类解决需求，重点还是在于数据检测，本着不能相信前端输入的数据的原则，要做好数据检测，也不是件轻而易举的事情，毕竟疯子的想法你是猜不透的。</p>
<p>这里针对数据检测，在这里说说我的通用做法，还是以例说明：</p>
<h3 id="1-场景：认证服务"><a href="#1-场景：认证服务" class="headerlink" title="1 场景：认证服务"></a>1 场景：认证服务</h3><p>这里只是简单的验证用户，根据用户输入的姓名，身份证号码，手机号码（需要填写手机号码是为了短信验证，这年头，不加点料，都对不起自己），验证输入的信息是否合法，当然这个验证不是很靠谱，只是为了做个例子而已，不用太当真，不然掉进了你是谁，我又是谁的黑洞，那就完蛋了。</p>
<h3 id="2-业务流程步骤"><a href="#2-业务流程步骤" class="headerlink" title="2 业务流程步骤"></a>2 业务流程步骤</h3><p>说明：代码以伪代码为主</p>
<h4 id="2-1-准备两个-serializer"><a href="#2-1-准备两个-serializer" class="headerlink" title="2.1 准备两个 serializer"></a>2.1 准备两个 serializer</h4><p>为什么要准备两个 <code>serializer</code>，因为：</p>
<ul>
<li>输入的数据结构和你期望返回的数据结构有可能是不一样的</li>
<li>业务拆分，保持业务独立，清晰</li>
</ul>
<p>检测数据的 serializer:</p>
<pre><code class="Python">class VerifyForm(serializers.Serializer):
    &quot;&quot;&quot;验证认证用户输入数据&quot;&quot;&quot;
    username = serializers.CharField(max_length=64, min_length=2)
    id_number = serializers.CharField(max_length=18, min_length=15)
    sms_code = serializers.CharField(max_length=6, min_length=6)

    def validate_username(self, value):
        if 检测输入的用户名不合法:
            raise 异常
        return value

    def validate_id_number(self, value):
        if 检测输入的身份证号码不合法:
            raise 异常
        return value

    def validate_sms_code(self, value):
        if 检测输入的短信验证码不合法:
            raise 异常
        return value

    def validate(self, attrs):
        if 外部服务(username, id_number) 不合法:
            raise 异常
        return attrs

    def create(self, validated_data):
         持久化
         return instance
</code></pre>
<p>序列化对象的 serializer:</p>
<pre><code class="python">class VerifySerializer(serializers.ModelSerializer):
    &quot;&quot;&quot;序列化数据&quot;&quot;&quot;

    你可以做点自己喜欢的事情，啊哈

    class Meta:
        model = Verify
        fields = &#39;__all__&#39;
</code></pre>
<h4 id="2-2-书写-views"><a href="#2-2-书写-views" class="headerlink" title="2.2 书写 views"></a>2.2 书写 views</h4><p>针对创建的业务，示例如下：</p>
<pre><code class="python">def perform_create(self, serializer):
    return serializer.save()

def create(self, request, *args, **kwargs):
    serializer = VerifyForm(data=request.data, context=&#123;&#39;request&#39;: request&#125;)
    # 检验数据
    serializer.is_valid(raise_exception=True)
    # 持久化
    instance = self.perform_create(serializer)
    # 序列化数据
    serializer = self.get_serializer(instance)

    return Response(serializer.data)
</code></pre>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>这种做法是我通常写接口业务的流程，验证检测归验证检测，序列化归序列化，两种类型互不干扰，当然对于简单的业务你可以全部放到同一个 serializer 中，这个根据自己的业务需求走，没有更好，只有合适。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Django-Rest-Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Django | 通用的开发包</title>
    <url>/posts/51719/</url>
    <content><![CDATA[<p>更新时间：2019-12-20 22:05:03</p>
<p>基于 <code>Django</code> 项目，通用的第三方开发工具包，这里只列出了通用的开发包，也包含了部分业务包，其他常见的涉及到具体的业务包，不再一一列出。</p>
<h4 id="1-DjangoRestFramework"><a href="#1-DjangoRestFramework" class="headerlink" title="1 DjangoRestFramework"></a>1 DjangoRestFramework</h4><p><a href="https://www.django-rest-framework.org/">https://www.django-rest-framework.org/</a></p>
<p>开发 <code>Restful</code> 接口的主力工具</p>
<h4 id="2-django-cors-headers"><a href="#2-django-cors-headers" class="headerlink" title="2 django-cors-headers"></a>2 django-cors-headers</h4><p><a href="https://github.com/adamchainz/django-cors-headers">https://github.com/adamchainz/django-cors-headers</a></p>
<p>解决前后端分离接口请求跨域</p>
<h4 id="3-django-extensions"><a href="#3-django-extensions" class="headerlink" title="3 django-extensions"></a>3 django-extensions</h4><p><a href="https://github.com/django-extensions/django-extensions">https://github.com/django-extensions/django-extensions</a></p>
<p><code>Django</code> 扩展增强工具</p>
<h4 id="4-ipython"><a href="#4-ipython" class="headerlink" title="4 ipython"></a>4 ipython</h4><p><a href="https://ipython.org/">https://ipython.org/</a></p>
<p>强大的交互式 <code>shell</code>，测试调试非常顺手，当然不仅仅限于 <code>Django</code> 开发</p>
<h4 id="5-django-environ"><a href="#5-django-environ" class="headerlink" title="5 django-environ"></a>5 django-environ</h4><p><a href="https://github.com/joke2k/django-environ">https://github.com/joke2k/django-environ</a></p>
<p>区分各种环境的配置利器</p>
<h4 id="6-celery"><a href="#6-celery" class="headerlink" title="6 celery"></a>6 celery</h4><p><a href="https://github.com/celery/celery">https://github.com/celery/celery</a></p>
<p>分布式的任务队列分发器</p>
<h4 id="7-wechatpy"><a href="#7-wechatpy" class="headerlink" title="7 wechatpy"></a>7 wechatpy</h4><p><a href="https://github.com/wechatpy/wechatpy">https://github.com/wechatpy/wechatpy</a></p>
<p>微信开发必备的 SDK</p>
<h4 id="8-gunicorn"><a href="#8-gunicorn" class="headerlink" title="8 gunicorn"></a>8 gunicorn</h4><p><a href="https://gunicorn.org/">https://gunicorn.org/</a></p>
<p><code>Python WSGI HTTP Server</code></p>
<h4 id="9-factory-boy"><a href="#9-factory-boy" class="headerlink" title="9 factory-boy"></a>9 factory-boy</h4><p><a href="https://github.com/FactoryBoy/factory_boy">https://github.com/FactoryBoy/factory_boy</a></p>
<p>测试数据生成工具</p>
<h4 id="10-parameterized"><a href="#10-parameterized" class="headerlink" title="10 parameterized"></a>10 parameterized</h4><p><a href="https://github.com/wolever/parameterized">https://github.com/wolever/parameterized</a></p>
<p>为测试用例提供参数化的，重复性支持</p>
<h4 id="11-pytest"><a href="#11-pytest" class="headerlink" title="11 pytest"></a>11 pytest</h4><p><a href="https://docs.pytest.org/en/latest/">https://docs.pytest.org/en/latest/</a></p>
<p>强大的第三方测试框架，丰富的插件集，活跃的社区</p>
<p>当然还有 <code>nose</code> 和 它的继任者 <code>nose2</code>，不过相比较而言，还是更加青睐于 <code>pytest</code></p>
<p><code>nose</code>：<a href="https://nose.readthedocs.io/en/latest/">https://nose.readthedocs.io/en/latest/</a><br><code>nose2</code>：<a href="https://github.com/nose-devs/nose2">https://github.com/nose-devs/nose2</a></p>
<p>不过 <code>nose</code> 已经不再更新，进入了维护阶段，如果使用建议使用 <code>nose2</code></p>
<h4 id="12-raven"><a href="#12-raven" class="headerlink" title="12 raven"></a>12 raven</h4><p><a href="https://raven.readthedocs.io/en/feature-federated-docs/">https://raven.readthedocs.io/en/feature-federated-docs/</a></p>
<p>这个一般都是结合 <code>Sentry</code> 使用</p>
<h4 id="13-mysqlclient"><a href="#13-mysqlclient" class="headerlink" title="13 mysqlclient"></a>13 mysqlclient</h4><p><a href="https://github.com/PyMySQL/mysqlclient-python">https://github.com/PyMySQL/mysqlclient-python</a></p>
<p>因为我使用 <code>Mysql</code> 较多</p>
<h4 id="14-django-silk"><a href="#14-django-silk" class="headerlink" title="14 django-silk"></a>14 django-silk</h4><p><a href="https://github.com/jazzband/django-silk">https://github.com/jazzband/django-silk</a></p>
<p>简单的性能监控工具</p>
<h4 id="15-django-debug-toolbar"><a href="#15-django-debug-toolbar" class="headerlink" title="15 django-debug-toolbar"></a>15 django-debug-toolbar</h4><p><a href="https://github.com/jazzband/django-debug-toolbar">https://github.com/jazzband/django-debug-toolbar</a></p>
<p><code>debug</code> 工具</p>
<h4 id="16-django-reversion"><a href="#16-django-reversion" class="headerlink" title="16 django-reversion"></a>16 django-reversion</h4><p><a href="https://github.com/etianen/django-reversion">https://github.com/etianen/django-reversion</a></p>
<p>模型版本控制</p>
<h4 id="17-whitenoise"><a href="#17-whitenoise" class="headerlink" title="17 whitenoise"></a>17 whitenoise</h4><p><a href="https://github.com/evansd/whitenoise">https://github.com/evansd/whitenoise</a></p>
<p>静态资源管理，通常是用来管理 <code>django admin</code> 和其他第三方包的静态资源。</p>
<h4 id="18-django-sql-explorer"><a href="#18-django-sql-explorer" class="headerlink" title="18 django-sql-explorer"></a>18 django-sql-explorer</h4><p><a href="https://github.com/groveco/django-sql-explorer">https://github.com/groveco/django-sql-explorer</a></p>
<p><code>SQL</code> 运行查询辅助工具</p>
<h4 id="19-django-import-export"><a href="#19-django-import-export" class="headerlink" title="19 django-import-export"></a>19 django-import-export</h4><p><a href="https://github.com/django-import-export/django-import-export">https://github.com/django-import-export/django-import-export</a></p>
<p>数据导入导出</p>
<h4 id="20-django-compressor"><a href="#20-django-compressor" class="headerlink" title="20 django-compressor"></a>20 django-compressor</h4><p><a href="https://django-compressor.readthedocs.io/en/stable/">https://django-compressor.readthedocs.io/en/stable/</a></p>
<p>合并静态资源，减少网络请求，一般使用在 <code>django admin</code> 中。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 | 重构 gulpfile.js</title>
    <url>/posts/18305/</url>
    <content><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h3><p>前端任务打包工具选用的是 <code>gulp</code>, 当时选用 <code>gulp</code> 也是偶然，在使用 <code>grunt</code> 初期，翻阅 <code>dailyjs.com</code> 时发现一片文章着重介绍了 <code>gulp</code>, 甚至还预言是 <code>grunt</code> 的劲敌，好奇心驱使，确实发现，<code>gulp</code> 的流的概念更人性化，看着当时写的 <code>grunt</code> 配置文件，不忍直视<span id="more"></span></p>
<p>由于项目的不断迭代，前端的任务也在不断的迭代，任务越来越多，没有优化前，全部的任务都在一个单独的 <code>gulpfile.js</code> 中，后来随着时间的推移，发现修改一个任务时，查询好麻烦，五百行左右的代码让人烦躁，代码结构和 <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/using-multiple-sources-in-one-task.md">https://github.com/gulpjs/gulp/blob/master/docs/recipes/using-multiple-sources-in-one-task.md</a> 如出一辙</p>
<p>重构 <code>gulpfile.js</code> 必须要进行</p>
<h3 id="2-重构迭代-1-拆分任务"><a href="#2-重构迭代-1-拆分任务" class="headerlink" title="2 重构迭代 1: 拆分任务"></a>2 重构迭代 1: 拆分任务</h3><p>最先是按照 <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/split-tasks-across-multiple-files.md">https://github.com/gulpjs/gulp/blob/master/docs/recipes/split-tasks-across-multiple-files.md</a> 此文档中的架构进行迭代的</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><pre><code class="javascript">    gulpfile.js
    tasks/
    ├── xxxx.js
    ├── xxxx.js
    └── image.js
</code></pre>
<h4 id="image-js"><a href="#image-js" class="headerlink" title="image.js"></a>image.js</h4><pre><code class="javascript">var imagemin = require(&quot;gulp-imagemin&quot;);

gulp.task(&quot;img&quot;, function () &#123;
  return gulp
    .src(&quot;./images/**/*.*&quot;)
    .pipe(
      imagemin(&#123;
        optimizationLevel: 2,
        progressive: true,
      &#125;)
    )
    .pipe(gulp.dest(&quot;./imagemini&quot;));
&#125;);
</code></pre>
<h4 id="gulpfile-js"><a href="#gulpfile-js" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h4><pre><code class="javascript">var requireDir = require(&quot;require-dir&quot;),
  tasks = requireDir(&quot;./tasks&quot;);
</code></pre>
<p>这种文件架构让任务按照类型分成子任务放在单独的文件中，顿时感觉干净了很多，这时可以自由的添加子任务，而不用管 <code>gulpfile.js</code>, 此时子任务好比插件，需要就添加，没用就删除，相当方便</p>
<h3 id="3-重构迭代-2-避免模块和插件重复依赖"><a href="#3-重构迭代-2-避免模块和插件重复依赖" class="headerlink" title="3 重构迭代 2: 避免模块和插件重复依赖"></a>3 重构迭代 2: 避免模块和插件重复依赖</h3><p>随着时间的推移，发现这种组织架构还是有些不方便，不方便在哪里呢，每一个任务文件中，我都要写 <code>var xxx = require(&#39;xxx&#39;)</code>, 如果你是用上面的架构，任务多的时候，估计也会抓狂，因为你会发现 <code>插件和模块依赖被重复的引入进来</code>，这样就提高了成本</p>
<p>我不想在子任务文件中重复的引入 <code>插件或模块依赖</code>，有没有上面好方法，<code>stackoverflow</code> 是个好老师，老师告知：</p>
<ul>
<li>使用 <code>gulp-load-plugins</code> 插件<br>地址：<a href="https://www.npmjs.com/package/gulp-load-plugins">https://www.npmjs.com/package/gulp-load-plugins</a></li>
<li>把子任务封装成模块</li>
</ul>
<h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><pre><code class="javascript">    gulpfile.js
    tasks/
    ├── xxxx.js
    ├── xxxx.js
    └── image.js
</code></pre>
<h4 id="gulpfile-js-1"><a href="#gulpfile-js-1" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h4><pre><code class="javascript">var gulp = require(&quot;gulp&quot;),
  gulpLoadPlugins = require(&quot;gulp-load-plugins&quot;);
// 这里请查看文档
gulpLoadPlugins.imagemin = require(&quot;gulp-imagemin&quot;);

require(&quot;./tasks/image&quot;)(gulp, gulpLoadPlugins);
</code></pre>
<h4 id="image-js-1"><a href="#image-js-1" class="headerlink" title="image.js"></a>image.js</h4><pre><code class="javascript">module.exports = function (gulp, Plugin) &#123;
  gulp.task(&quot;img&quot;, function () &#123;
    return gulp
      .src(&quot;./images/**/*.*&quot;)
      .pipe(
        Plugin.imagemin(&#123;
          optimizationLevel: 2,
          progressive: true,
        &#125;)
      )
      .pipe(gulp.dest(&quot;./imagemini&quot;));
  &#125;);
&#125;;
</code></pre>
<p>运行任务 一切正常，此时一个文件测试已经 ok</p>
<p>但是 <code>./tasks</code> 下面是有很多的子任务，所以需要一个迭代加载，修改 <code>gulpfile.js</code> 如下</p>
<pre><code class="javascript">var gulp = require(&quot;gulp&quot;),
  gulpLoadPlugins = require(&quot;gulp-load-plugins&quot;),
  // 这里获取子任务文件列表 使用了 fs 模块
  gulpTaskList = require(&quot;fs&quot;).readdirSync(&quot;./tasks/&quot;);
// 这里请查看文档
gulpLoadPlugins.imagemin = require(&quot;gulp-imagemin&quot;);

gulpTaskList.forEach(function (taskfile) &#123;
  require(&quot;./tasks/&quot; + taskfile)(gulp, gulpLoadPlugins);
&#125;);
</code></pre>
<p>这一次迭代避免了<code>重复依赖</code>的问题，但是你会发现，所有的依赖都声明在 <code>gulpTaskList</code> 命名空间下，如果你依赖很多插件或模块，<code>gulpfile.js</code> 也是相当长，鱼和熊掌不可兼得，在现在情况下，只能寻找最佳的解决方案</p>
<h3 id="4-重构迭代-3-参数配置全局化"><a href="#4-重构迭代-3-参数配置全局化" class="headerlink" title="4 重构迭代 3: 参数配置全局化"></a>4 重构迭代 3: 参数配置全局化</h3><p>其实第二部迭代之后，就可以满足大部分需求，但还是有小伙伴抱怨，有些子任务有相同的参数，能不能抽取出来，放到一个单独的文件中，so 继续翻阅文档</p>
<p>参考文档<a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/using-external-config-file.md">https://github.com/gulpjs/gulp/blob/master/docs/recipes/using-external-config-file.md</a></p>
<h4 id="代码结构-1"><a href="#代码结构-1" class="headerlink" title="代码结构"></a>代码结构</h4><pre><code class="javascript">    gulpfile.js
    gulp
    ├── config.json
    ├── tasks/
        ├── xxxx.js
        ├── xxxx.js
        └── image.js
</code></pre>
<p><code>注意：文件夹层次变了</code></p>
<h4 id="config-json"><a href="#config-json" class="headerlink" title="config.json"></a>config.json</h4><pre><code class="javascript">    &#123;
        &quot;pnglevel&quot;: 2
    &#125;
</code></pre>
<h4 id="gulpfile-js-2"><a href="#gulpfile-js-2" class="headerlink" title="gulpfile.js"></a>gulpfile.js</h4><pre><code class="javascript">    var gulp = require(&#39;gulp&#39;)
      , config = require(&#39;./gulp/config.json&#39;);
      , gulpLoadPlugins = require(&#39;gulp-load-plugins&#39;)
      , gulpTaskList = require(&#39;fs&#39;).readdirSync(&#39;./gulp/tasks/&#39;)
      ;

    gulpLoadPlugins.imagemin = require(&#39;gulp-imagemin&#39;);

    gulpTaskList.forEach(function(taskfile) &#123;
        require(&#39;./gulp/tasks/&#39; + taskfile)(gulp, gulpLoadPlugins, config);
    &#125;);
</code></pre>
<h4 id="image-js-2"><a href="#image-js-2" class="headerlink" title="image.js"></a>image.js</h4><pre><code class="javascript">module.exports = function (gulp, Plugin, config) &#123;
  gulp.task(&quot;img&quot;, function () &#123;
    return gulp
      .src(&quot;./images/**/*.*&quot;)
      .pipe(
        Plugin.imagemin(&#123;
          optimizationLevel: config.pnglevel,
          progressive: true,
        &#125;)
      )
      .pipe(gulp.dest(&quot;./imagemini&quot;));
  &#125;);
&#125;;
</code></pre>
<p>此次迭代结束后，我把子任务中通用的配置都写到 <code>./gulp/config.json</code> 中，全局配置</p>
<h3 id="5-重构迭代-4-参数配置模块化"><a href="#5-重构迭代-4-参数配置模块化" class="headerlink" title="5 重构迭代 4: 参数配置模块化"></a>5 重构迭代 4: 参数配置模块化</h3><p>此次迭代紧跟迭代 3，<code>json</code> 不够完美，不想每次去写 <code>&quot;&quot;</code>, 这里我把配置文件封装成一个模块</p>
<p>即迭代 3 中的 <code>config.json</code> 变成了 <code>config.js</code></p>
<h4 id="config-js"><a href="#config-js" class="headerlink" title="config.js"></a>config.js</h4><pre><code class="javascript">module.exports = function () &#123;
  var config = &#123;
    pnglevel: 2,
  &#125;;
  return config;
&#125;;
</code></pre>
<h4 id="gulpfile-js-加载"><a href="#gulpfile-js-加载" class="headerlink" title="gulpfile.js 加载"></a>gulpfile.js 加载</h4><pre><code class="javascript">var config = require(&quot;./gulp/gulp.config&quot;)();
</code></pre>
<p>其他不变，当封装成一个模块的时候，你就发现好处多多了，可以在模块中添加函数，你也可以把配置拆分，根据你的业务需要，自由调整</p>
<h3 id="6-后记"><a href="#6-后记" class="headerlink" title="6 后记"></a>6 后记</h3><p>通过 4 步的迭代，整个代码组织架构就清晰多了，很感谢这么多热爱开源，乐于助人的朋友，谢谢</p>
<p>注意： 子任务中注意文件夹的层次，子任务中的文件夹是以 <code>gulpfile.js</code> 为基准，因为 <code>gulpfile.js</code> 把子任务都包含进来了</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 不同的发行版设置静态 IP</title>
    <url>/posts/29624/</url>
    <content><![CDATA[<p>近来在折腾本地服务器，为了方式每次重启 IP 地址的变化，所以要给机器设置静态 IP <span id="more"></span></p>
<h2 id="一-不同发行版静态-IP-设置"><a href="#一-不同发行版静态-IP-设置" class="headerlink" title="一 不同发行版静态 IP 设置"></a>一 不同发行版静态 IP 设置</h2><h3 id="1-Centos-设置静态-IP"><a href="#1-Centos-设置静态-IP" class="headerlink" title="1 Centos 设置静态 IP"></a>1 Centos 设置静态 IP</h3><h4 id="修改网络配置"><a href="#修改网络配置" class="headerlink" title="修改网络配置"></a>修改网络配置</h4><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth192
</code></pre>
<p>修改后的内容如下</p>
<pre><code>TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
# 这里可以使用 static 或者 no
BOOTPROTO=none
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens192
UUID=cd93f1df-d2d5-4c63-a64c-761e9ee23aae
DEVICE=ens192
# 开机启用此配置
ONBOOT=yes
# 静态 IP
IPADDR=192.168.1.12
# 默认网关
GATEWAY=192.168.1.1
</code></pre>
<h4 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h4><pre><code>systemctl restart network
</code></pre>
<h4 id="查看地址"><a href="#查看地址" class="headerlink" title="查看地址"></a>查看地址</h4><pre><code class="shell">[isproot@192 ~]$ ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:51:63:21 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.12/24 brd 192.168.1.255 scope global noprefixroute ens192
       valid_lft forever preferred_lft forever
    inet6 2408:8256:a80:313:6ba6:7ad0:edd0:defe/64 scope global noprefixroute dynamic
       valid_lft 183241sec preferred_lft 96841sec
    inet6 fe80::b6f3:1daa:4b7b:6994/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
</code></pre>
<h3 id="2-Debian-设置静态-IP"><a href="#2-Debian-设置静态-IP" class="headerlink" title="2 Debian 设置静态 IP"></a>2 Debian 设置静态 IP</h3><h4 id="修改网络配置-1"><a href="#修改网络配置-1" class="headerlink" title="修改网络配置"></a>修改网络配置</h4><pre><code class="shell">vi /etc/network/interfaces
</code></pre>
<p>修改后的内容如下</p>
<pre><code class="shell"># This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
allow-hotplug ens192
# iface ens192 inet dhcp
# 设置成静态 IP
iface ens192 inet static
# 设置 IP
address 192.168.1.11
# 设置子网掩码
netmask 255.255.255.0
# 设置网关
gateway 192.168.1.1
# 设置 DNS 服务器，我这里设置成路由器的地址
dns-nameservers 192.168.1.1
# This is an autoconfigured IPv6 interface
iface ens192 inet6 auto
</code></pre>
<h4 id="重启网络服务-1"><a href="#重启网络服务-1" class="headerlink" title="重启网络服务"></a>重启网络服务</h4><pre><code>service networking restart
</code></pre>
<h4 id="查看地址-1"><a href="#查看地址-1" class="headerlink" title="查看地址"></a>查看地址</h4><pre><code class="shell">root@debian:~# ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: ens192: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:0a:14:07 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.11/24 brd 192.168.1.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 2408:8256:a81:c14f:20c:29ff:fe0a:1407/64 scope global dynamic mngtmpaddr
       valid_lft 206755sec preferred_lft 120355sec
    inet6 fe80::20c:29ff:fe0a:1407/64 scope link
       valid_lft forever preferred_lft forever
</code></pre>
<h2 id="二-小结"><a href="#二-小结" class="headerlink" title="二 小结"></a>二 小结</h2><p>从配置的过程来看，基本上都是配置文件的目录和配置项不同而已，其他基本上都差不多，毕竟原理都是一样的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Debian</tag>
      </tags>
  </entry>
  <entry>
    <title>本地开发使用 https</title>
    <url>/posts/32953/</url>
    <content><![CDATA[<p>这阵子本地开发测试，需要本地可以使用 HTTPS 证书，找到了 <code>mkcert</code> 这个傻瓜式的工具（<a href="https://github.com/FiloSottile/mkcert">https://github.com/FiloSottile/mkcert</a>),</p>
<p>mkcert 设计很简单，优雅，隐藏了几乎所有生成 TLS 证书所必须的知识，它适用于任何域名，主机名，IP，包括 localhost，但是切记，只能在本地使用。<span id="more"></span></p>
<p>证书是由你自己的私有 CA 签发，当你运行 <code>mkcert-install</code> 会自动配置这些信任，因此，当浏览器访问时，就会显示安全标识。</p>
<p>与 OpenSSL 不同的是，不需要为每个证书配置很多选项。mkcert 最主要的功能是作为开发者工具，聚焦于让本地环境配置 TLS 证书变得简单高效。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><pre><code class="shell">brew install mkcert
brew install nss # if you use Firefox
</code></pre>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><p>您需要首先在系统信任库中安装本地 CA.</p>
<pre><code class="shell">$ mkcert -install

Using the local CA at &quot;/Users/kycool/Library/Application Support/mkcert&quot; ✨
The local CA is already installed in the system trust store! 👍
</code></pre>
<p>完成后，可以给自己的本地域名生成证书了，生成证书很简单</p>
<pre><code class="shell">$ sudo mkcert kycooltest.cn &#39;*.kycooltest.cn&#39; localhost 127.0.0.1 ::1
Using the local CA at &quot;/Users/kycool/Library/Application Support/mkcert&quot; ✨

Created a new certificate valid for the following names 📜
 - &quot;kycooltest.cn&quot;
 - &quot;*.kycooltest.cn&quot;
 - &quot;localhost&quot;
 - &quot;127.0.0.1&quot;
 - &quot;::1&quot;

Reminder: X.509 wildcards only go one level deep, so this won&#39;t match a.b.kycooltest.cn ℹ️

The certificate is at &quot;./kycooltest.cn+4.pem&quot; and the key at &quot;./kycooltest.cn+4-key.pem&quot; ✅
</code></pre>
<h3 id="3-验证"><a href="#3-验证" class="headerlink" title="3 验证"></a>3 验证</h3><p>添加本地 <code>hosts</code> 记录</p>
<pre><code class="python">127.0.0.1 kycooltest.cn
</code></pre>
<p>添加 nginx 配置文件</p>
<pre><code class="python">server &#123;
    listen *:443 ssl;
    server_name  kycooltest.cn;

    root /var/www;

    ssl_certificate /Users/kycool/Documents/caddy/kycooltest.cn+4.pem;
    ssl_certificate_key /Users/kycool/Documents/caddy/kycooltest.cn+4-key.pem;
&#125;
</code></pre>
<p>接着在 浏览器中打开 <code>https://kycooltest.cn</code></p>
<p><img src="/images/mkcert.png" alt="mkcert.png"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Medium | 非订阅下阅读文章</title>
    <url>/posts/40149/</url>
    <content><![CDATA[<p>在不用订阅的情况下，不受限制的阅读文章，我一般都是使用 PC 进行阅读，因为宽屏看东西，比较爽。<span id="more"></span>列举下方法</p>
<h3 id="1-chrome-使用无痕模式"><a href="#1-chrome-使用无痕模式" class="headerlink" title="1 chrome 使用无痕模式"></a>1 chrome 使用无痕模式</h3><p>复制链接地址到无痕窗口打开，即可正常阅读。</p>
<p>缺点：每次阅读文章都需要走这样一篇流程，有些浪费功夫，对于我这样的 <code>medium</code> 重度用户，心态是要崩掉的。但是如果只是偶尔阅读下，可以这样操作。</p>
<h3 id="2-使用插件：medium-unlimited"><a href="#2-使用插件：medium-unlimited" class="headerlink" title="2 使用插件：medium-unlimited"></a>2 使用插件：medium-unlimited</h3><p>地址：<a href="https://github.com/manojVivek/medium-unlimited">https://github.com/manojVivek/medium-unlimited</a></p>
<p>安装后，即可顺滑流畅的享受阅读。</p>
<p>缺点：受浏览器限制，其实这个也不算是什么缺点，毕竟 <code>chrome</code> 和 <code>firefox</code> 算是很不错的浏览器了。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序未找到入口 sitemap.json</title>
    <url>/posts/6541/</url>
    <content><![CDATA[<p><code>Error</code>: 未找到入口 <code>sitemap.json</code> 文件，或者文件读取失败，请检查后重新编译</p>
<span id="more"></span>

<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h3><p>今天在微信开发者工具中发现了一个错误，这个错误一直没有注意到。</p>
<pre><code>`Error`: 未找到入口 `sitemap.json` 文件，或者文件读取失败，请检查后重新编译
</code></pre>
<p>这个错误不会影响小程序的正常使用，查阅了文档（<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html%60">微信小程序 sitemap.json</a>），才知道这个文件是用来给微信小程序搜索建立索引用的，下面再仔细分析下这个功能。</p>
<h3 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2 解决方法"></a>2 解决方法</h3><p>第一步：我根据错误描述，在 app.jsx(我使用了 Taro) 同级目录下新建了一个 <code>sitemap.json</code> 文件，内容如下:</p>
<pre><code class="json">&#123;
  &quot;rules&quot;: [
    &#123;
      &quot;action&quot;: &quot;allow&quot;,
      &quot;page&quot;: &quot;*&quot;
    &#125;
  ]
&#125;
</code></pre>
<p>第二步：接着在 <code>app.jsx</code> 中的 <code>config</code> 中添加</p>
<pre><code>sitemapLocation: &#39;sitemap.json&#39;,
</code></pre>
<p>然后编译测试，发现还是出现同样的错误，然后发现 <code>dist</code> 文件夹下面没有 <code>sitemap.json</code> 文件，这个可能是 <code>Taro</code> 不支持的原因，但是 <code>Taro</code> 还是提供了一个 <code>copy</code> 的编译功能（<a href="https://nervjs.github.io/taro/docs/config-detail.html#copy">Taro 编译配置 copy</a>)，摘出来如下：</p>
<blockquote>
<p>copy</p>
</blockquote>
<p>文件 <code>copy</code> 配置，包含两个配置项 <code>patterns</code> 和 <code>options</code>。</p>
<p><strong>copy.patterns</strong></p>
<p>用来指定需要拷贝的文件或者目录，数组类型，每一项都必须包含 <code>from</code> 、<code>to</code> 的配置，分别代表来源和需要拷贝到的目录，同时可以设置 <code>ignore</code> 配置来指定需要忽略的文件， <code>ignore</code> 是指定的 <code>glob</code> 类型字符串，或者 glob 字符串数组。</p>
<p>值得注意的是，目前 <code>from</code> 必须指定存在的文件或者目录，暂不支持 <code>glob</code> 格式， <code>from</code> 和 <code>to</code> 直接置顶项目根目录下的文件目录，建议 <code>from</code> 以 <code>src</code> 目录开头，<code>to</code> 以 <code>dist</code> 目录开头。</p>
<p>一般有如下的使用形式：</p>
<pre><code>copy: &#123;
    patterns: [
        &#123; from: &#39;src/asset/tt/&#39;, to: &#39;dist/asset/tt/&#39;, ignore: &#39;*.js&#39; &#125;, // 指定需要 copy 的目录
        &#123; from: &#39;src/asset/tt/sd.jpg&#39;, to: &#39;dist/asset/tt/sd.jpg&#39; &#125; // 指定需要 copy 的文件
    ]
&#125;,
</code></pre>
<p><strong>copy.options</strong></p>
<p>拷贝配置，目前可以指定全局的 <code>ignore</code>：</p>
<pre><code>copy: &#123;
    options: &#123;
        ignore: [&#39;*.js&#39;, &#39;*.css&#39;] // 全局的 ignore
    &#125;
&#125;
</code></pre>
<p>第三步：好了，看完文档后，直接修改 <code>Taro</code> 的配置文件，添加以下内容：</p>
<pre><code>copy: &#123;
    patterns: [
        &#123;
            from: &#39;src/sitemap.json&#39;,
            to: &#39;dist/sitemap.json&#39;
        &#125;
    ],
    options: &#123;&#125;
&#125;,
</code></pre>
<p>再次编译测试，正常，查看 <code>dist</code> 文件夹也存在 <code>sitemap.json</code> 文件。</p>
<h3 id="3-聊下-sitemap"><a href="#3-聊下-sitemap" class="headerlink" title="3 聊下 sitemap"></a>3 聊下 sitemap</h3><p>这个功能不错，增加小程序的曝光度，而且开发者还可以根据业务需要自定义被索引的页面，很实用。如果你不关心这些东西，就参考我的 <code>sitemap.json</code> 配置。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Taro</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac-解锁网易云置灰音乐</title>
    <url>/posts/41185/</url>
    <content><![CDATA[<p>我的网易云黑胶会员 VIP 到期了，暂时不想续期，找了个法子解锁置灰的歌，后面再想想续期的事情。解锁的原理比较简单，劫持网易云音乐客户端的请求，打到代理服务中去，代理服务会自动解析，如果有些歌听不了，会自动请求其他音源进行替换，这个大家都懂的。下面记录下步骤。<span id="more"></span></p>
<p>工具和对应的版本：</p>
<ul>
<li>网易云音乐 for mac：2.0.0 (690) 下载地址：<a href="http://d1.music.126.net/dmusic/NeteaseMusic_2.0.0_690_web.dmg">http://d1.music.126.net/dmusic/NeteaseMusic_2.0.0_690_web.dmg</a></li>
<li>mac: 10.15.5 (19F101)</li>
<li>node: v10.16.3</li>
<li>Proxifier for mac: v2.26 下载地址: <a href="https://xclient.info/s/proxifier.html">https://xclient.info/s/proxifier.html</a></li>
</ul>
<h3 id="1-下载解锁项目"><a href="#1-下载解锁项目" class="headerlink" title="1 下载解锁项目"></a>1 下载解锁项目</h3><p>Github：<a href="https://github.com/nondanee/UnblockNeteaseMusic">https://github.com/nondanee/UnblockNeteaseMusic</a></p>
<p>这里照着文档克隆，然后双击安装其中的 ca.crt 并设置信任。因为后面要跑服务，新建了 m.sh 并赋予可执行的权限，直接用 m.sh 代码如下</p>
<pre><code class="shell">#!/bin/bash

pattern=&#39;[(].*[)]&#39;
# 注意这里改成自己的目录地址
path=~/Documents/githubpro/UnblockNeteaseMusic/app.js

# 这里是获取 music.163.com 的 IP 地址
ip=`ping music.163.com -c 1 | grep -o $pattern`
ip=$&#123;ip:1&#125;
ip=$&#123;ip%?&#125;

# 这里的端口号自己可以调整
sudo node app.js -p 63455:7777 -f $ip
</code></pre>
<p>然后在包含 m.sh 的目录下执行 m.sh</p>
<pre><code class="shell">$ ./m.sh

HTTP Server running @ http://0.0.0.0:63455
HTTPS Server running @ http://0.0.0.0:7777
</code></pre>
<p>注意：ping music.163.com 出来的 IP 地址有可能是变化的，so 如果歌听不了，重新运行服务即可。</p>
<h3 id="2-代理设置"><a href="#2-代理设置" class="headerlink" title="2 代理设置"></a>2 代理设置</h3><p>因为网易云 mac 的客户端没有可以设置代理的地方，有些傲娇，那就使用 Proxifier 来解决吧。</p>
<p>2.1 添加 Proxies，地址写 127.0.0.1 端口对应上面，为 63455<br>2.2 添加 Rules</p>
<pre><code class="python">Applications 为 NeteaseMusic;com.apple.WebKit.Networking

Target Hosts 为 *.music.163.com;*.music.126.net;*.netease.com;music.163.com;interface.music.163.com

Action 为上面创建的，即 Proxy HTTPS 127.0.0.1:63455
</code></pre>
<p>2.3 DNS 配置<br>在 Resolve hostnames through proxy 前面打勾</p>
<p>好了，代理配置好了。</p>
<h3 id="3-重启网易云音乐"><a href="#3-重启网易云音乐" class="headerlink" title="3 重启网易云音乐"></a>3 重启网易云音乐</h3><p>搜索 JAY 的歌，之前置灰的歌可以播放了，例如听以父之名，日志如下：</p>
<pre><code class="shell">TUNNEL &gt; localhost:63455
MITM &gt; music.163.com
MITM &gt; music.163.com
[1400394244] 以父之名 (Live)
http://sz.sycdn.kuwo.cn/cadd34fd7d42d643db5257b182f07ad5/5f57a6b9/resource/n1/69/17/1415834243.mp3
MITM &gt; music.163.com
</code></pre>
<p>使用这种方式听歌呢，因为要跑服务和代理，so 最好还是用脚本打开网易云音乐，省事。</p>
]]></content>
      <categories>
        <category>危险边缘</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
</search>
